/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * BPL Backend API
 * This is the backend API for the BPL project.
 *
 * OpenAPI spec version: 2.0
 * Contact: Liberatorist@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AggregationType {
    SUM_LATEST = 'SUM_LATEST',
    EARLIEST = 'EARLIEST',
    EARLIEST_FRESH_ITEM = 'EARLIEST_FRESH_ITEM',
    MAXIMUM = 'MAXIMUM',
    MINIMUM = 'MINIMUM'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ApplicationStatus {
    applied = 'applied',
    accepted = 'accepted',
    waitlisted = 'waitlisted',
    none = 'none'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ApprovalStatus {
    APPROVED = 'APPROVED',
    REJECTED = 'REJECTED',
    PENDING = 'PENDING'
}

/**
 * 
 * @export
 * @interface Atlas
 */
export interface Atlas {
    /**
     * 
     * @type {number}
     * @memberof Atlas
     */
    event_id: number;
    /**
     * 
     * @type {number}
     * @memberof Atlas
     */
    index: number;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof Atlas
     */
    trees: Array<Array<number>>;
    /**
     * 
     * @type {number}
     * @memberof Atlas
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface CallbackBody
 */
export interface CallbackBody {
    /**
     * 
     * @type {string}
     * @memberof CallbackBody
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackBody
     */
    redirect_url: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackBody
     */
    state: string;
}

/**
 * 
 * @export
 * @interface CallbackResponse
 */
export interface CallbackResponse {
    /**
     * 
     * @type {string}
     * @memberof CallbackResponse
     */
    auth_token: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackResponse
     */
    last_path: string;
    /**
     * 
     * @type {User}
     * @memberof CallbackResponse
     */
    user: User;
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {Array<Objective>}
     * @memberof Category
     */
    objectives: Array<Objective>;
    /**
     * 
     * @type {ScoringPreset}
     * @memberof Category
     */
    scoring_preset?: ScoringPreset;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {Array<Category>}
     * @memberof Category
     */
    sub_categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    parent_id: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryCreate
     */
    scoring_preset_id?: number;
}

/**
 * 
 * @export
 * @interface Character
 */
export interface Character {
    /**
     * 
     * @type {string}
     * @memberof Character
     */
    ascendancy: string;
    /**
     * 
     * @type {number}
     * @memberof Character
     */
    ascendancy_points: number;
    /**
     * 
     * @type {number}
     * @memberof Character
     */
    atlas_node_count: number;
    /**
     * 
     * @type {number}
     * @memberof Character
     */
    event_id: number;
    /**
     * 
     * @type {number}
     * @memberof Character
     */
    level: number;
    /**
     * 
     * @type {string}
     * @memberof Character
     */
    main_skill: string;
    /**
     * 
     * @type {string}
     * @memberof Character
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Character
     */
    pantheon: boolean;
    /**
     * 
     * @type {string}
     * @memberof Character
     */
    timestamp: string;
    /**
     * 
     * @type {number}
     * @memberof Character
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {ItemField}
     * @memberof Condition
     */
    field: ItemField;
    /**
     * 
     * @type {number}
     * @memberof Condition
     */
    id: number;
    /**
     * 
     * @type {Operator}
     * @memberof Condition
     */
    operator: Operator;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ConditionCreate
 */
export interface ConditionCreate {
    /**
     * 
     * @type {ItemField}
     * @memberof ConditionCreate
     */
    field: ItemField;
    /**
     * 
     * @type {number}
     * @memberof ConditionCreate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ConditionCreate
     */
    objective_id: number;
    /**
     * 
     * @type {Operator}
     * @memberof ConditionCreate
     */
    operator: Operator;
    /**
     * 
     * @type {string}
     * @memberof ConditionCreate
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ConditionMappings
 */
export interface ConditionMappings {
    /**
     * 
     * @type {{ [key: string]: FieldType; }}
     * @memberof ConditionMappings
     */
    field_to_type: { [key: string]: FieldType; };
    /**
     * 
     * @type {{ [key: string]: Array<NumberField>; }}
     * @memberof ConditionMappings
     */
    objective_type_to_number_fields: { [key: string]: Array<NumberField>; };
    /**
     * 
     * @type {{ [key: string]: Array<Operator>; }}
     * @memberof ConditionMappings
     */
    valid_operators: { [key: string]: Array<Operator>; };
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Difftype {
    Added = 'Added',
    Removed = 'Removed',
    Changed = 'Changed',
    Unchanged = 'Unchanged'
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    application_start_time: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    event_end_time: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    event_start_time: string;
    /**
     * 
     * @type {GameVersion}
     * @memberof Event
     */
    game_version: GameVersion;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    id: number;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    is_current: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    is_locked: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    is_public: boolean;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    max_size: number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * 
     * @type {Array<Team>}
     * @memberof Event
     */
    teams: Array<Team>;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    waitlist_size: number;
}

/**
 * 
 * @export
 * @interface EventCreate
 */
export interface EventCreate {
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    application_start_time: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    event_end_time: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    event_start_time: string;
    /**
     * 
     * @type {GameVersion}
     * @memberof EventCreate
     */
    game_version: GameVersion;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventCreate
     */
    is_current?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventCreate
     */
    is_locked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventCreate
     */
    is_public?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    max_size: number;
    /**
     * 
     * @type {string}
     * @memberof EventCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof EventCreate
     */
    waitlist_size: number;
}

/**
 * 
 * @export
 * @interface EventStatus
 */
export interface EventStatus {
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof EventStatus
     */
    application_status: ApplicationStatus;
    /**
     * 
     * @type {boolean}
     * @memberof EventStatus
     */
    is_team_lead: boolean;
    /**
     * 
     * @type {number}
     * @memberof EventStatus
     */
    number_of_signups: number;
    /**
     * 
     * @type {number}
     * @memberof EventStatus
     */
    team_id?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum FieldType {
    string = 'string',
    int = 'int',
    bool = 'bool',
    string_2 = 'string[]'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum GameVersion {
    poe1 = 'poe1',
    poe2 = 'poe2'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ItemField {
    BASE_TYPE = 'BASE_TYPE',
    NAME = 'NAME',
    ITEM_CLASS = 'ITEM_CLASS',
    TYPE_LINE = 'TYPE_LINE',
    QUALITY = 'QUALITY',
    LEVEL = 'LEVEL',
    RARITY = 'RARITY',
    ILVL = 'ILVL',
    FRAME_TYPE = 'FRAME_TYPE',
    TALISMAN_TIER = 'TALISMAN_TIER',
    ENCHANT_MODS = 'ENCHANT_MODS',
    EXPLICIT_MODS = 'EXPLICIT_MODS',
    IMPLICIT_MODS = 'IMPLICIT_MODS',
    CRAFTED_MODS = 'CRAFTED_MODS',
    FRACTURED_MODS = 'FRACTURED_MODS',
    INFLUENCES = 'INFLUENCES',
    MAX_LINKS = 'MAX_LINKS',
    SOCKETS = 'SOCKETS',
    INCUBATOR_KILLS = 'INCUBATOR_KILLS',
    IS_CORRUPTED = 'IS_CORRUPTED',
    IS_VAAL = 'IS_VAAL',
    IS_SPLIT = 'IS_SPLIT',
    SANCTUM_AFFLICTIONS = 'SANCTUM_AFFLICTIONS',
    TEMPLE_ROOMS = 'TEMPLE_ROOMS',
    RITUAL_VESSEL_BOSSES = 'RITUAL_VESSEL_BOSSES',
    RITUAL_VESSEL_MAP = 'RITUAL_VESSEL_MAP'
}

/**
 * 
 * @export
 * @interface JobCreate
 */
export interface JobCreate {
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    duration_in_seconds?: number;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    end_date?: string;
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    event_id?: number;
    /**
     * 
     * @type {JobType}
     * @memberof JobCreate
     */
    job_type?: JobType;
    /**
     * 
     * @type {number}
     * @memberof JobCreate
     */
    sleep_after_each_run_seconds?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum JobType {
    FetchStashChanges = 'FetchStashChanges',
    EvaluateStashChanges = 'EvaluateStashChanges',
    FetchCharacterData = 'FetchCharacterData'
}

/**
 * 
 * @export
 * @interface LadderEntry
 */
export interface LadderEntry {
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    account_name: string;
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    character_class: string;
    /**
     * 
     * @type {string}
     * @memberof LadderEntry
     */
    character_name: string;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    delve: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    experience: number;
    /**
     * 
     * @type {Character}
     * @memberof LadderEntry
     */
    extra?: Character;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    level: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    rank: number;
    /**
     * 
     * @type {number}
     * @memberof LadderEntry
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface MinimalUser
 */
export interface MinimalUser {
    /**
     * 
     * @type {string}
     * @memberof MinimalUser
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof MinimalUser
     */
    id: number;
}

/**
 * 
 * @export
 * @interface NonSensitiveUser
 */
export interface NonSensitiveUser {
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    discord_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    discord_name?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof NonSensitiveUser
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    twitch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonSensitiveUser
     */
    twitch_name?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum NumberField {
    STACK_SIZE = 'STACK_SIZE',
    PLAYER_LEVEL = 'PLAYER_LEVEL',
    DELVE_DEPTH = 'DELVE_DEPTH',
    PANTHEON = 'PANTHEON',
    ASCENDANCY = 'ASCENDANCY',
    PLAYER_SCORE = 'PLAYER_SCORE',
    SUBMISSION_VALUE = 'SUBMISSION_VALUE'
}

/**
 * 
 * @export
 * @interface Objective
 */
export interface Objective {
    /**
     * 
     * @type {AggregationType}
     * @memberof Objective
     */
    aggregation: AggregationType;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    category_id: number;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Objective
     */
    conditions: Array<Condition>;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    extra: string;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    name: string;
    /**
     * 
     * @type {NumberField}
     * @memberof Objective
     */
    number_field: NumberField;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof Objective
     */
    objective_type: ObjectiveType;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    required_number: number;
    /**
     * 
     * @type {ScoringPreset}
     * @memberof Objective
     */
    scoring_preset?: ScoringPreset;
    /**
     * 
     * @type {number}
     * @memberof Objective
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    valid_from?: string;
    /**
     * 
     * @type {string}
     * @memberof Objective
     */
    valid_to?: string;
}

/**
 * 
 * @export
 * @interface ObjectiveConditionCreate
 */
export interface ObjectiveConditionCreate {
    /**
     * 
     * @type {ObjectiveConditionCreateField}
     * @memberof ObjectiveConditionCreate
     */
    field: ObjectiveConditionCreateField;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveConditionCreate
     */
    id?: number;
    /**
     * 
     * @type {ObjectiveConditionCreateField}
     * @memberof ObjectiveConditionCreate
     */
    operator: ObjectiveConditionCreateField;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveConditionCreate
     */
    value: string;
}

/**
 * 
 * @export
 * @interface ObjectiveConditionCreateField
 */
export interface ObjectiveConditionCreateField {
}

/**
 * 
 * @export
 * @interface ObjectiveCreate
 */
export interface ObjectiveCreate {
    /**
     * 
     * @type {AggregationType}
     * @memberof ObjectiveCreate
     */
    aggregation: AggregationType;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    category_id: number;
    /**
     * 
     * @type {Array<ObjectiveConditionCreate>}
     * @memberof ObjectiveCreate
     */
    conditions: Array<ObjectiveConditionCreate>;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    extra?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    name: string;
    /**
     * 
     * @type {NumberField}
     * @memberof ObjectiveCreate
     */
    number_field: NumberField;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof ObjectiveCreate
     */
    objective_type: ObjectiveType;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    required_number: number;
    /**
     * 
     * @type {number}
     * @memberof ObjectiveCreate
     */
    scoring_preset_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    valid_from?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectiveCreate
     */
    valid_to?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ObjectiveType {
    ITEM = 'ITEM',
    PLAYER = 'PLAYER',
    SUBMISSION = 'SUBMISSION'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Operator {
    EQ = 'EQ',
    NEQ = 'NEQ',
    GT = 'GT',
    LT = 'LT',
    IN = 'IN',
    NOT_IN = 'NOT_IN',
    MATCHES = 'MATCHES',
    CONTAINS = 'CONTAINS',
    CONTAINS_MATCH = 'CONTAINS_MATCH',
    LENGTH_EQ = 'LENGTH_EQ',
    LENGTH_GT = 'LENGTH_GT',
    LENGTH_LT = 'LENGTH_LT'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Permission {
    admin = 'admin',
    command_team = 'command_team',
    objective_designer = 'objective_designer',
    judge = 'judge'
}

/**
 * 
 * @export
 * @interface RecurringJob
 */
export interface RecurringJob {
    /**
     * 
     * @type {string}
     * @memberof RecurringJob
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringJob
     */
    event_id: number;
    /**
     * 
     * @type {JobType}
     * @memberof RecurringJob
     */
    job_type: JobType;
    /**
     * 
     * @type {number}
     * @memberof RecurringJob
     */
    sleep_after_each_run_seconds: number;
}

/**
 * 
 * @export
 * @interface Score
 */
export interface Score {
    /**
     * 
     * @type {boolean}
     * @memberof Score
     */
    finished: boolean;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    number: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    points: number;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    rank: number;
    /**
     * 
     * @type {string}
     * @memberof Score
     */
    timestamp: string;
    /**
     * 
     * @type {number}
     * @memberof Score
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface ScoreDiff
 */
export interface ScoreDiff {
    /**
     * 
     * @type {Difftype}
     * @memberof ScoreDiff
     */
    diff_type: Difftype;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoreDiff
     */
    field_diff: Array<string>;
    /**
     * 
     * @type {Score}
     * @memberof ScoreDiff
     */
    score: Score;
}

/**
 * 
 * @export
 * @interface ScoreMap
 */
export interface ScoreMap {
    [key: string]: ScoreDiff;

}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoringMethod {
    PRESENCE = 'PRESENCE',
    POINTS_FROM_VALUE = 'POINTS_FROM_VALUE',
    RANKED_TIME = 'RANKED_TIME',
    RANKED_VALUE = 'RANKED_VALUE',
    RANKED_REVERSE = 'RANKED_REVERSE',
    RANKED_COMPLETION_TIME = 'RANKED_COMPLETION_TIME',
    BONUS_PER_COMPLETION = 'BONUS_PER_COMPLETION'
}

/**
 * 
 * @export
 * @interface ScoringPreset
 */
export interface ScoringPreset {
    /**
     * 
     * @type {string}
     * @memberof ScoringPreset
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof ScoringPreset
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ScoringPreset
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScoringPreset
     */
    points: Array<number>;
    /**
     * 
     * @type {ScoringMethod}
     * @memberof ScoringPreset
     */
    scoring_method: ScoringMethod;
    /**
     * 
     * @type {ScoringPresetType}
     * @memberof ScoringPreset
     */
    type: ScoringPresetType;
}

/**
 * 
 * @export
 * @interface ScoringPresetCreate
 */
export interface ScoringPresetCreate {
    /**
     * 
     * @type {string}
     * @memberof ScoringPresetCreate
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoringPresetCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ScoringPresetCreate
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScoringPresetCreate
     */
    points: Array<number>;
    /**
     * 
     * @type {ScoringMethod}
     * @memberof ScoringPresetCreate
     */
    scoring_method: ScoringMethod;
    /**
     * 
     * @type {ScoringPresetType}
     * @memberof ScoringPresetCreate
     */
    type: ScoringPresetType;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ScoringPresetType {
    OBJECTIVE = 'OBJECTIVE',
    CATEGORY = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface Signup
 */
export interface Signup {
    /**
     * 
     * @type {number}
     * @memberof Signup
     */
    expected_playtime: number;
    /**
     * 
     * @type {number}
     * @memberof Signup
     */
    id: number;
    /**
     * 
     * @type {boolean}
     * @memberof Signup
     */
    needs_help?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Signup
     */
    team_id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Signup
     */
    team_lead: boolean;
    /**
     * 
     * @type {string}
     * @memberof Signup
     */
    timestamp: string;
    /**
     * 
     * @type {NonSensitiveUser}
     * @memberof Signup
     */
    user: NonSensitiveUser;
    /**
     * 
     * @type {boolean}
     * @memberof Signup
     */
    wants_to_help?: boolean;
}

/**
 * 
 * @export
 * @interface SignupCreate
 */
export interface SignupCreate {
    /**
     * 
     * @type {number}
     * @memberof SignupCreate
     */
    expected_playtime: number;
    /**
     * 
     * @type {boolean}
     * @memberof SignupCreate
     */
    needs_help?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SignupCreate
     */
    wants_to_help?: boolean;
}

/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof Submission
     */
    approval_status: ApprovalStatus;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    comment: string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    number: number;
    /**
     * 
     * @type {Objective}
     * @memberof Submission
     */
    objective?: Objective;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    proof: string;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    review_comment?: string;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    reviewer_id?: number;
    /**
     * 
     * @type {number}
     * @memberof Submission
     */
    team_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    timestamp: string;
    /**
     * 
     * @type {NonSensitiveUser}
     * @memberof Submission
     */
    user?: NonSensitiveUser;
}

/**
 * 
 * @export
 * @interface SubmissionCreate
 */
export interface SubmissionCreate {
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionCreate
     */
    objective_id: number;
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    proof?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionCreate
     */
    timestamp: string;
}

/**
 * 
 * @export
 * @interface SubmissionReview
 */
export interface SubmissionReview {
    /**
     * 
     * @type {ObjectiveConditionCreateField}
     * @memberof SubmissionReview
     */
    approval_status: ObjectiveConditionCreateField;
    /**
     * 
     * @type {string}
     * @memberof SubmissionReview
     */
    review_comment?: string;
}

/**
 * 
 * @export
 * @interface SuggestionCreate
 */
export interface SuggestionCreate {
    /**
     * 
     * @type {number}
     * @memberof SuggestionCreate
     */
    id: number;
}

/**
 * 
 * @export
 * @interface Suggestions
 */
export interface Suggestions {
    /**
     * 
     * @type {Array<number>}
     * @memberof Suggestions
     */
    category_ids: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Suggestions
     */
    objective_ids: Array<number>;
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {Array<string>}
     * @memberof Team
     */
    allowed_classes: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    event_id: number;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name: string;
}

/**
 * 
 * @export
 * @interface TeamCreate
 */
export interface TeamCreate {
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamCreate
     */
    allowed_classes: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TeamCreate
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamCreate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamCreate
     */
    name: string;
}

/**
 * 
 * @export
 * @interface TeamUserCreate
 */
export interface TeamUserCreate {
    /**
     * 
     * @type {boolean}
     * @memberof TeamUserCreate
     */
    is_team_lead?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TeamUserCreate
     */
    team_id?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamUserCreate
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface TwitchStream
 */
export interface TwitchStream {
    /**
     * 
     * @type {number}
     * @memberof TwitchStream
     */
    backend_user_id?: number;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    game_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    game_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TwitchStream
     */
    is_mature?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    started_at?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitchStream
     */
    tag_ids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwitchStream
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_login?: string;
    /**
     * 
     * @type {string}
     * @memberof TwitchStream
     */
    user_name?: string;
    /**
     * 
     * @type {number}
     * @memberof TwitchStream
     */
    viewer_count?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    account_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    discord_id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    discord_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof User
     */
    permissions: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    token_expiry_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    twitch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    twitch_name?: string;
}

/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    display_name: string;
}


/**
 * AtlasApi - fetch parameter creator
 * @export
 */
export const AtlasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get atlas trees for your team for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAtlasesForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeamAtlasesForEvent.');
            }
            const localVarPath = `/events/{event_id}/atlas`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtlasApi - functional programming interface
 * @export
 */
export const AtlasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get atlas trees for your team for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAtlasesForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Atlas>> {
            const localVarFetchArgs = AtlasApiFetchParamCreator(configuration).getTeamAtlasesForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AtlasApi - factory interface
 * @export
 */
export const AtlasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get atlas trees for your team for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamAtlasesForEvent(event_id: number, options?: any) {
            return AtlasApiFp(configuration).getTeamAtlasesForEvent(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * AtlasApi - object-oriented interface
 * @export
 * @class AtlasApi
 * @extends {BaseAPI}
 */
export class AtlasApi extends BaseAPI {
    /**
     * Get atlas trees for your team for an event
     * @param {number} event_id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtlasApi
     */
    public getTeamAtlasesForEvent(event_id: number, options?: any) {
        return AtlasApiFp(this.configuration).getTeamAtlasesForEvent(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * CharactersApi - fetch parameter creator
 * @export
 */
export const CharactersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all character data for an event for a user
         * @param {number} event_id Event ID
         * @param {number} user_id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterEventHistoryForUser(event_id: number, user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getCharacterEventHistoryForUser.');
            }
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling getCharacterEventHistoryForUser.');
            }
            const localVarPath = `/characters/{user_id}/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all characters for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getCharactersForEvent.');
            }
            const localVarPath = `/events/{event_id}/characters`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all event characters for a user
         * @param {number} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCharacters(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserCharacters.');
            }
            const localVarPath = `/characters/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharactersApi - functional programming interface
 * @export
 */
export const CharactersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all character data for an event for a user
         * @param {number} event_id Event ID
         * @param {number} user_id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterEventHistoryForUser(event_id: number, user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Character>> {
            const localVarFetchArgs = CharactersApiFetchParamCreator(configuration).getCharacterEventHistoryForUser(event_id, user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all characters for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Character>> {
            const localVarFetchArgs = CharactersApiFetchParamCreator(configuration).getCharactersForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all event characters for a user
         * @param {number} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCharacters(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Character>> {
            const localVarFetchArgs = CharactersApiFetchParamCreator(configuration).getUserCharacters(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CharactersApi - factory interface
 * @export
 */
export const CharactersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all character data for an event for a user
         * @param {number} event_id Event ID
         * @param {number} user_id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterEventHistoryForUser(event_id: number, user_id: number, options?: any) {
            return CharactersApiFp(configuration).getCharacterEventHistoryForUser(event_id, user_id, options)(fetch, basePath);
        },
        /**
         * Get all characters for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersForEvent(event_id: number, options?: any) {
            return CharactersApiFp(configuration).getCharactersForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all event characters for a user
         * @param {number} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCharacters(userId: number, options?: any) {
            return CharactersApiFp(configuration).getUserCharacters(userId, options)(fetch, basePath);
        },
    };
};

/**
 * CharactersApi - object-oriented interface
 * @export
 * @class CharactersApi
 * @extends {BaseAPI}
 */
export class CharactersApi extends BaseAPI {
    /**
     * Get all character data for an event for a user
     * @param {number} event_id Event ID
     * @param {number} user_id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public getCharacterEventHistoryForUser(event_id: number, user_id: number, options?: any) {
        return CharactersApiFp(this.configuration).getCharacterEventHistoryForUser(event_id, user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all characters for an event
     * @param {number} event_id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public getCharactersForEvent(event_id: number, options?: any) {
        return CharactersApiFp(this.configuration).getCharactersForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all event characters for a user
     * @param {number} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public getUserCharacters(userId: number, options?: any) {
        return CharactersApiFp(this.configuration).getUserCharacters(userId, options)(this.fetch, this.basePath);
    }

}

/**
 * ConditionApi - fetch parameter creator
 * @export
 */
export const ConditionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a condition
         * @param {number} event_id Event Id
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(event_id: number, condition: ConditionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createCondition.');
            }
            // verify required parameter 'condition' is not null or undefined
            if (condition === null || condition === undefined) {
                throw new RequiredError('condition','Required parameter condition was null or undefined when calling createCondition.');
            }
            const localVarPath = `/events/{event_id}/conditions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConditionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(condition || {}) : (condition || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a condition
         * @param {number} event_id Event Id
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteCondition.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCondition.');
            }
            const localVarPath = `/events/{event_id}/conditions/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get valid mappings for conditions
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getValidMappings.');
            }
            const localVarPath = `/events/{event_id}/conditions/valid-mappings`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionApi - functional programming interface
 * @export
 */
export const ConditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a condition
         * @param {number} event_id Event Id
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(event_id: number, condition: ConditionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Condition> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).createCondition(event_id, condition, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a condition
         * @param {number} event_id Event Id
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).deleteCondition(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get valid mappings for conditions
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConditionMappings> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).getValidMappings(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConditionApi - factory interface
 * @export
 */
export const ConditionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a condition
         * @param {number} event_id Event Id
         * @param {ConditionCreate} condition Condition to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCondition(event_id: number, condition: ConditionCreate, options?: any) {
            return ConditionApiFp(configuration).createCondition(event_id, condition, options)(fetch, basePath);
        },
        /**
         * Deletes a condition
         * @param {number} event_id Event Id
         * @param {number} id Condition Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCondition(event_id: number, id: number, options?: any) {
            return ConditionApiFp(configuration).deleteCondition(event_id, id, options)(fetch, basePath);
        },
        /**
         * Get valid mappings for conditions
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidMappings(event_id: number, options?: any) {
            return ConditionApiFp(configuration).getValidMappings(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * ConditionApi - object-oriented interface
 * @export
 * @class ConditionApi
 * @extends {BaseAPI}
 */
export class ConditionApi extends BaseAPI {
    /**
     * Creates a condition
     * @param {number} event_id Event Id
     * @param {ConditionCreate} condition Condition to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public createCondition(event_id: number, condition: ConditionCreate, options?: any) {
        return ConditionApiFp(this.configuration).createCondition(event_id, condition, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a condition
     * @param {number} event_id Event Id
     * @param {number} id Condition Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public deleteCondition(event_id: number, id: number, options?: any) {
        return ConditionApiFp(this.configuration).deleteCondition(event_id, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get valid mappings for conditions
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public getValidMappings(event_id: number, options?: any) {
        return ConditionApiFp(this.configuration).getValidMappings(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * EventApi - fetch parameter creator
 * @export
 */
export const EventApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling createEvent.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(event || {}) : (event || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteEvent.');
            }
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling duplicateEvent.');
            }
            // verify required parameter 'event' is not null or undefined
            if (event === null || event === undefined) {
                throw new RequiredError('event','Required parameter event was null or undefined when calling duplicateEvent.');
            }
            const localVarPath = `/events/{event_id}/duplicate`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(event || {}) : (event || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an event by id
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getEvent.');
            }
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the status for an event including the user's application status
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatus(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getEventStatus.');
            }
            const localVarPath = `/events/{event_id}/status`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).createEvent(event, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).deleteEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).duplicateEvent(event_id, event, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an event by id
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the status for an event including the user's application status
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatus(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventStatus> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEventStatus(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventApiFetchParamCreator(configuration).getEvents(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates or updates an event
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(event: EventCreate, options?: any) {
            return EventApiFp(configuration).createEvent(event, options)(fetch, basePath);
        },
        /**
         * Deletes an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(event_id: number, options?: any) {
            return EventApiFp(configuration).deleteEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Duplicates an event's configuration
         * @param {number} event_id Event Id
         * @param {EventCreate} event Event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateEvent(event_id: number, event: EventCreate, options?: any) {
            return EventApiFp(configuration).duplicateEvent(event_id, event, options)(fetch, basePath);
        },
        /**
         * Fetches an event by id
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(event_id: number, options?: any) {
            return EventApiFp(configuration).getEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Gets the status for an event including the user's application status
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventStatus(event_id: number, options?: any) {
            return EventApiFp(configuration).getEventStatus(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any) {
            return EventApiFp(configuration).getEvents(options)(fetch, basePath);
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Creates or updates an event
     * @param {EventCreate} event Event to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public createEvent(event: EventCreate, options?: any) {
        return EventApiFp(this.configuration).createEvent(event, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public deleteEvent(event_id: number, options?: any) {
        return EventApiFp(this.configuration).deleteEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Duplicates an event's configuration
     * @param {number} event_id Event Id
     * @param {EventCreate} event Event to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public duplicateEvent(event_id: number, event: EventCreate, options?: any) {
        return EventApiFp(this.configuration).duplicateEvent(event_id, event, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches an event by id
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEvent(event_id: number, options?: any) {
        return EventApiFp(this.configuration).getEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the status for an event including the user's application status
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventStatus(event_id: number, options?: any) {
        return EventApiFp(this.configuration).getEventStatus(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEvents(options?: any) {
        return EventApiFp(this.configuration).getEvents(options)(this.fetch, this.basePath);
    }

}

/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options: any = {}): FetchArgs {
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options: any = {}): FetchArgs {
            // verify required parameter 'job' is not null or undefined
            if (job === null || job === undefined) {
                throw new RequiredError('job','Required parameter job was null or undefined when calling startJob.');
            }
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JobCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(job || {}) : (job || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RecurringJob>> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJobs(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecurringJob> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).startJob(job, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all recurring jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(options?: any) {
            return JobsApiFp(configuration).getJobs(options)(fetch, basePath);
        },
        /**
         * Start a recurring job
         * @param {JobCreate} job Job to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startJob(job: JobCreate, options?: any) {
            return JobsApiFp(configuration).startJob(job, options)(fetch, basePath);
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Get all recurring jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobs(options?: any) {
        return JobsApiFp(this.configuration).getJobs(options)(this.fetch, this.basePath);
    }

    /**
     * Start a recurring job
     * @param {JobCreate} job Job to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public startJob(job: JobCreate, options?: any) {
        return JobsApiFp(this.configuration).startJob(job, options)(this.fetch, this.basePath);
    }

}

/**
 * LadderApi - fetch parameter creator
 * @export
 */
export const LadderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getLadder.');
            }
            const localVarPath = `/events/{event_id}/ladder`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LadderApi - functional programming interface
 * @export
 */
export const LadderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
            const localVarFetchArgs = LadderApiFetchParamCreator(configuration).getLadder(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LadderApi - factory interface
 * @export
 */
export const LadderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the ladder for an event
         * @param {number} event_id Event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLadder(event_id: number, options?: any) {
            return LadderApiFp(configuration).getLadder(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * LadderApi - object-oriented interface
 * @export
 * @class LadderApi
 * @extends {BaseAPI}
 */
export class LadderApi extends BaseAPI {
    /**
     * Get the ladder for an event
     * @param {number} event_id Event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LadderApi
     */
    public getLadder(event_id: number, options?: any) {
        return LadderApiFp(this.configuration).getLadder(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * OauthApi - fetch parameter creator
 * @export
 */
export const OauthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(options: any = {}): FetchArgs {
            const localVarPath = `/oauth2/discord/bot-login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Callback handler for oauth
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {CallbackBody} body Callback body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(provider: 'poe' | 'twitch' | 'discord', body: CallbackBody, options: any = {}): FetchArgs {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling oauthCallback.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling oauthCallback.');
            }
            const localVarPath = `/oauth2/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CallbackBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to an oauth provider
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {string} [redirect_url] Redirect URL for oauth provider
         * @param {string} [last_url] Last URL to redirect to after oauth is finished
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRedirect(provider: 'poe' | 'twitch' | 'discord', redirect_url?: string, last_url?: string, options: any = {}): FetchArgs {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling oauthRedirect.');
            }
            const localVarPath = `/oauth2/{provider}/redirect`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (redirect_url !== undefined) {
                localVarQueryParameter['redirect_url'] = redirect_url;
            }

            if (last_url !== undefined) {
                localVarQueryParameter['last_url'] = last_url;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).loginDiscordBot(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Callback handler for oauth
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {CallbackBody} body Callback body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(provider: 'poe' | 'twitch' | 'discord', body: CallbackBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CallbackResponse> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthCallback(provider, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirects to an oauth provider
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {string} [redirect_url] Redirect URL for oauth provider
         * @param {string} [last_url] Last URL to redirect to after oauth is finished
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRedirect(provider: 'poe' | 'twitch' | 'discord', redirect_url?: string, last_url?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthRedirect(provider, redirect_url, last_url, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Logs in the discord bot (only for internal use)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginDiscordBot(options?: any) {
            return OauthApiFp(configuration).loginDiscordBot(options)(fetch, basePath);
        },
        /**
         * Callback handler for oauth
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {CallbackBody} body Callback body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(provider: 'poe' | 'twitch' | 'discord', body: CallbackBody, options?: any) {
            return OauthApiFp(configuration).oauthCallback(provider, body, options)(fetch, basePath);
        },
        /**
         * Redirects to an oauth provider
         * @param {'poe' | 'twitch' | 'discord'} provider Provider name
         * @param {string} [redirect_url] Redirect URL for oauth provider
         * @param {string} [last_url] Last URL to redirect to after oauth is finished
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRedirect(provider: 'poe' | 'twitch' | 'discord', redirect_url?: string, last_url?: string, options?: any) {
            return OauthApiFp(configuration).oauthRedirect(provider, redirect_url, last_url, options)(fetch, basePath);
        },
    };
};

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
    /**
     * Logs in the discord bot (only for internal use)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public loginDiscordBot(options?: any) {
        return OauthApiFp(this.configuration).loginDiscordBot(options)(this.fetch, this.basePath);
    }

    /**
     * Callback handler for oauth
     * @param {'poe' | 'twitch' | 'discord'} provider Provider name
     * @param {CallbackBody} body Callback body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthCallback(provider: 'poe' | 'twitch' | 'discord', body: CallbackBody, options?: any) {
        return OauthApiFp(this.configuration).oauthCallback(provider, body, options)(this.fetch, this.basePath);
    }

    /**
     * Redirects to an oauth provider
     * @param {'poe' | 'twitch' | 'discord'} provider Provider name
     * @param {string} [redirect_url] Redirect URL for oauth provider
     * @param {string} [last_url] Last URL to redirect to after oauth is finished
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthRedirect(provider: 'poe' | 'twitch' | 'discord', redirect_url?: string, last_url?: string, options?: any) {
        return OauthApiFp(this.configuration).oauthRedirect(provider, redirect_url, last_url, options)(this.fetch, this.basePath);
    }

}

/**
 * ObjectiveApi - fetch parameter creator
 * @export
 */
export const ObjectiveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new objective
         * @param {number} event_id Event Id
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(event_id: number, body: ObjectiveCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createObjective.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createObjective.');
            }
            const localVarPath = `/events/{event_id}/objectives`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ObjectiveCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an objective
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteObjective.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteObjective.');
            }
            const localVarPath = `/events/{event_id}/objectives/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an objective by id
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getObjective.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getObjective.');
            }
            const localVarPath = `/events/{event_id}/objectives/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectiveApi - functional programming interface
 * @export
 */
export const ObjectiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new objective
         * @param {number} event_id Event Id
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(event_id: number, body: ObjectiveCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Objective> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).createObjective(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an objective
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).deleteObjective(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets an objective by id
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Objective> {
            const localVarFetchArgs = ObjectiveApiFetchParamCreator(configuration).getObjective(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ObjectiveApi - factory interface
 * @export
 */
export const ObjectiveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new objective
         * @param {number} event_id Event Id
         * @param {ObjectiveCreate} body Objective to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjective(event_id: number, body: ObjectiveCreate, options?: any) {
            return ObjectiveApiFp(configuration).createObjective(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes an objective
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjective(event_id: number, id: number, options?: any) {
            return ObjectiveApiFp(configuration).deleteObjective(event_id, id, options)(fetch, basePath);
        },
        /**
         * Gets an objective by id
         * @param {number} event_id Event Id
         * @param {number} id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjective(event_id: number, id: number, options?: any) {
            return ObjectiveApiFp(configuration).getObjective(event_id, id, options)(fetch, basePath);
        },
    };
};

/**
 * ObjectiveApi - object-oriented interface
 * @export
 * @class ObjectiveApi
 * @extends {BaseAPI}
 */
export class ObjectiveApi extends BaseAPI {
    /**
     * Creates a new objective
     * @param {number} event_id Event Id
     * @param {ObjectiveCreate} body Objective to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public createObjective(event_id: number, body: ObjectiveCreate, options?: any) {
        return ObjectiveApiFp(this.configuration).createObjective(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an objective
     * @param {number} event_id Event Id
     * @param {number} id Objective Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public deleteObjective(event_id: number, id: number, options?: any) {
        return ObjectiveApiFp(this.configuration).deleteObjective(event_id, id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets an objective by id
     * @param {number} event_id Event Id
     * @param {number} id Objective Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectiveApi
     */
    public getObjective(event_id: number, id: number, options?: any) {
        return ObjectiveApiFp(this.configuration).getObjective(event_id, id, options)(this.fetch, this.basePath);
    }

}

/**
 * ScoresApi - fetch parameter creator
 * @export
 */
export const ScoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getLatestScoresForEvent.');
            }
            const localVarPath = `/events/{event_id}/scores/latest`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling scoreWebSocket.');
            }
            const localVarPath = `/events/{event_id}/scores/ws`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Websocket for simple score updates.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleScoreWebSocket(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling simpleScoreWebSocket.');
            }
            const localVarPath = `/events/{event_id}/scores/simple/ws`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoresApi - functional programming interface
 * @export
 */
export const ScoresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreMap> {
            const localVarFetchArgs = ScoresApiFetchParamCreator(configuration).getLatestScoresForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreDiff> {
            const localVarFetchArgs = ScoresApiFetchParamCreator(configuration).scoreWebSocket(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Websocket for simple score updates.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleScoreWebSocket(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
            const localVarFetchArgs = ScoresApiFetchParamCreator(configuration).simpleScoreWebSocket(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoresApi - factory interface
 * @export
 */
export const ScoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches the latest scores for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestScoresForEvent(event_id: number, options?: any) {
            return ScoresApiFp(configuration).getLatestScoresForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Websocket for score updates. Once connected, the client will receive score updates in real-time.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreWebSocket(event_id: number, options?: any) {
            return ScoresApiFp(configuration).scoreWebSocket(event_id, options)(fetch, basePath);
        },
        /**
         * Websocket for simple score updates.
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleScoreWebSocket(event_id: number, options?: any) {
            return ScoresApiFp(configuration).simpleScoreWebSocket(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * ScoresApi - object-oriented interface
 * @export
 * @class ScoresApi
 * @extends {BaseAPI}
 */
export class ScoresApi extends BaseAPI {
    /**
     * Fetches the latest scores for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public getLatestScoresForEvent(event_id: number, options?: any) {
        return ScoresApiFp(this.configuration).getLatestScoresForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Websocket for score updates. Once connected, the client will receive score updates in real-time.
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public scoreWebSocket(event_id: number, options?: any) {
        return ScoresApiFp(this.configuration).scoreWebSocket(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Websocket for simple score updates.
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public simpleScoreWebSocket(event_id: number, options?: any) {
        return ScoresApiFp(this.configuration).simpleScoreWebSocket(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * ScoringApi - fetch parameter creator
 * @export
 */
export const ScoringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scoring category
         * @param {number} event_id Event Id
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(event_id: number, body: CategoryCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createCategory.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategory.');
            }
            const localVarPath = `/events/{event_id}/categories`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new scoring preset
         * @param {number} event_id Event Id
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(event_id: number, body: ScoringPresetCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createScoringPreset.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createScoringPreset.');
            }
            const localVarPath = `/events/{event_id}/scoring-presets`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScoringPresetCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a scoring category
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteCategory.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/events/{event_id}/categories/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} event_id Event Id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteScoringPreset.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteScoringPreset.');
            }
            const localVarPath = `/events/{event_id}/scoring-presets/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getRulesForEvent.');
            }
            const localVarPath = `/events/{event_id}/categories`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a scoring category by id
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(event_id: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getScoringCategory.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getScoringCategory.');
            }
            const localVarPath = `/events/{event_id}/categories/{id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getScoringPresetsForEvent.');
            }
            const localVarPath = `/events/{event_id}/scoring-presets`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoringApi - functional programming interface
 * @export
 */
export const ScoringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new scoring category
         * @param {number} event_id Event Id
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(event_id: number, body: CategoryCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).createCategory(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new scoring preset
         * @param {number} event_id Event Id
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(event_id: number, body: ScoringPresetCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoringPreset> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).createScoringPreset(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a scoring category
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).deleteCategory(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} event_id Event Id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).deleteScoringPreset(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getRulesForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a scoring category by id
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(event_id: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Category> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getScoringCategory(event_id, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ScoringPreset>> {
            const localVarFetchArgs = ScoringApiFetchParamCreator(configuration).getScoringPresetsForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoringApi - factory interface
 * @export
 */
export const ScoringApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new scoring category
         * @param {number} event_id Event Id
         * @param {CategoryCreate} body Category to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(event_id: number, body: CategoryCreate, options?: any) {
            return ScoringApiFp(configuration).createCategory(event_id, body, options)(fetch, basePath);
        },
        /**
         * Creates a new scoring preset
         * @param {number} event_id Event Id
         * @param {ScoringPresetCreate} body Preset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoringPreset(event_id: number, body: ScoringPresetCreate, options?: any) {
            return ScoringApiFp(configuration).createScoringPreset(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes a scoring category
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(event_id: number, id: number, options?: any) {
            return ScoringApiFp(configuration).deleteCategory(event_id, id, options)(fetch, basePath);
        },
        /**
         * Deletes a scoring preset by id
         * @param {number} event_id Event Id
         * @param {number} id Preset Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoringPreset(event_id: number, id: number, options?: any) {
            return ScoringApiFp(configuration).deleteScoringPreset(event_id, id, options)(fetch, basePath);
        },
        /**
         * Fetches the rules for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesForEvent(event_id: number, options?: any) {
            return ScoringApiFp(configuration).getRulesForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches a scoring category by id
         * @param {number} event_id Event Id
         * @param {number} id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringCategory(event_id: number, id: number, options?: any) {
            return ScoringApiFp(configuration).getScoringCategory(event_id, id, options)(fetch, basePath);
        },
        /**
         * Fetches the scoring presets for the current event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoringPresetsForEvent(event_id: number, options?: any) {
            return ScoringApiFp(configuration).getScoringPresetsForEvent(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * ScoringApi - object-oriented interface
 * @export
 * @class ScoringApi
 * @extends {BaseAPI}
 */
export class ScoringApi extends BaseAPI {
    /**
     * Creates a new scoring category
     * @param {number} event_id Event Id
     * @param {CategoryCreate} body Category to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public createCategory(event_id: number, body: CategoryCreate, options?: any) {
        return ScoringApiFp(this.configuration).createCategory(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new scoring preset
     * @param {number} event_id Event Id
     * @param {ScoringPresetCreate} body Preset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public createScoringPreset(event_id: number, body: ScoringPresetCreate, options?: any) {
        return ScoringApiFp(this.configuration).createScoringPreset(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a scoring category
     * @param {number} event_id Event Id
     * @param {number} id Category Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public deleteCategory(event_id: number, id: number, options?: any) {
        return ScoringApiFp(this.configuration).deleteCategory(event_id, id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a scoring preset by id
     * @param {number} event_id Event Id
     * @param {number} id Preset Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public deleteScoringPreset(event_id: number, id: number, options?: any) {
        return ScoringApiFp(this.configuration).deleteScoringPreset(event_id, id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the rules for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getRulesForEvent(event_id: number, options?: any) {
        return ScoringApiFp(this.configuration).getRulesForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a scoring category by id
     * @param {number} event_id Event Id
     * @param {number} id Category Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getScoringCategory(event_id: number, id: number, options?: any) {
        return ScoringApiFp(this.configuration).getScoringCategory(event_id, id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the scoring presets for the current event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoringApi
     */
    public getScoringPresetsForEvent(event_id: number, options?: any) {
        return ScoringApiFp(this.configuration).getScoringPresetsForEvent(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * SignupApi - fetch parameter creator
 * @export
 */
export const SignupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createSignup.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignupCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getEventSignups.');
            }
            const localVarPath = `/events/{event_id}/signups`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getPersonalSignup.');
            }
            const localVarPath = `/events/{event_id}/signups/self`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignupApi - functional programming interface
 * @export
 */
export const SignupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Signup> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).createSignup(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).deleteSignup(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Signup>> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).getEventSignups(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Signup> {
            const localVarFetchArgs = SignupApiFetchParamCreator(configuration).getPersonalSignup(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignupApi - factory interface
 * @export
 */
export const SignupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a signup for the authenticated user
         * @param {number} event_id Event Id
         * @param {SignupCreate} body Signup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignup(event_id: number, body: SignupCreate, options?: any) {
            return SignupApiFp(configuration).createSignup(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes the authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignup(event_id: number, options?: any) {
            return SignupApiFp(configuration).deleteSignup(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all signups for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSignups(event_id: number, options?: any) {
            return SignupApiFp(configuration).getEventSignups(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches an authenticated user's signup for the event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalSignup(event_id: number, options?: any) {
            return SignupApiFp(configuration).getPersonalSignup(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * SignupApi - object-oriented interface
 * @export
 * @class SignupApi
 * @extends {BaseAPI}
 */
export class SignupApi extends BaseAPI {
    /**
     * Creates a signup for the authenticated user
     * @param {number} event_id Event Id
     * @param {SignupCreate} body Signup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public createSignup(event_id: number, body: SignupCreate, options?: any) {
        return SignupApiFp(this.configuration).createSignup(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes the authenticated user's signup for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public deleteSignup(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).deleteSignup(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all signups for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public getEventSignups(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).getEventSignups(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches an authenticated user's signup for the event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignupApi
     */
    public getPersonalSignup(event_id: number, options?: any) {
        return SignupApiFp(this.configuration).getPersonalSignup(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options: any = {}): FetchArgs {
            const localVarPath = `/streams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TwitchStream>> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getStreams(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetches all twitch streams for the current event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options?: any) {
            return StreamsApiFp(configuration).getStreams(options)(fetch, basePath);
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * Fetches all twitch streams for the current event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getStreams(options?: any) {
        return StreamsApiFp(this.configuration).getStreams(options)(this.fetch, this.basePath);
    }

}

/**
 * SubmissionApi - fetch parameter creator
 * @export
 */
export const SubmissionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteSubmission.');
            }
            // verify required parameter 'submission_id' is not null or undefined
            if (submission_id === null || submission_id === undefined) {
                throw new RequiredError('submission_id','Required parameter submission_id was null or undefined when calling deleteSubmission.');
            }
            const localVarPath = `/events/{event_id}/submissions/{submission_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submission_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getSubmissions.');
            }
            const localVarPath = `/events/{event_id}/submissions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling reviewSubmission.');
            }
            // verify required parameter 'submission_id' is not null or undefined
            if (submission_id === null || submission_id === undefined) {
                throw new RequiredError('submission_id','Required parameter submission_id was null or undefined when calling reviewSubmission.');
            }
            // verify required parameter 'submission' is not null or undefined
            if (submission === null || submission === undefined) {
                throw new RequiredError('submission','Required parameter submission was null or undefined when calling reviewSubmission.');
            }
            const localVarPath = `/events/{event_id}/submissions/{submission_id}/review`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submission_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionReview" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(submission || {}) : (submission || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling submitBounty.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitBounty.');
            }
            const localVarPath = `/events/{event_id}/submissions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).deleteSubmission(event_id, submission_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submission>> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).getSubmissions(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submission> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).reviewSubmission(event_id, submission_id, submission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submission> {
            const localVarFetchArgs = SubmissionApiFetchParamCreator(configuration).submitBounty(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(event_id: number, submission_id: number, options?: any) {
            return SubmissionApiFp(configuration).deleteSubmission(event_id, submission_id, options)(fetch, basePath);
        },
        /**
         * Fetches all submissions for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(event_id: number, options?: any) {
            return SubmissionApiFp(configuration).getSubmissions(event_id, options)(fetch, basePath);
        },
        /**
         * Reviews a submission
         * @param {number} event_id Event Id
         * @param {number} submission_id Submission Id
         * @param {SubmissionReview} submission Submission review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any) {
            return SubmissionApiFp(configuration).reviewSubmission(event_id, submission_id, submission, options)(fetch, basePath);
        },
        /**
         * Submits a bounty for an event
         * @param {number} event_id Event Id
         * @param {SubmissionCreate} body Submission to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBounty(event_id: number, body: SubmissionCreate, options?: any) {
            return SubmissionApiFp(configuration).submitBounty(event_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI {
    /**
     * Deletes a submission
     * @param {number} event_id Event Id
     * @param {number} submission_id Submission Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public deleteSubmission(event_id: number, submission_id: number, options?: any) {
        return SubmissionApiFp(this.configuration).deleteSubmission(event_id, submission_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all submissions for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public getSubmissions(event_id: number, options?: any) {
        return SubmissionApiFp(this.configuration).getSubmissions(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Reviews a submission
     * @param {number} event_id Event Id
     * @param {number} submission_id Submission Id
     * @param {SubmissionReview} submission Submission review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public reviewSubmission(event_id: number, submission_id: number, submission: SubmissionReview, options?: any) {
        return SubmissionApiFp(this.configuration).reviewSubmission(event_id, submission_id, submission, options)(this.fetch, this.basePath);
    }

    /**
     * Submits a bounty for an event
     * @param {number} event_id Event Id
     * @param {SubmissionCreate} body Submission to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public submitBounty(event_id: number, body: SubmissionCreate, options?: any) {
        return SubmissionApiFp(this.configuration).submitBounty(event_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamApi - fetch parameter creator
 * @export
 */
export const TeamApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling addUsersToTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addUsersToTeams.');
            }
            const localVarPath = `/events/{event_id}/teams/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TeamUserCreate&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryTeamSuggestion(event_id: number, body: SuggestionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createCategoryTeamSuggestion.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategoryTeamSuggestion.');
            }
            const localVarPath = `/events/{event_id}/suggestions/categories`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SuggestionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjectiveTeamSuggestion(event_id: number, body: SuggestionCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createObjectiveTeamSuggestion.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createObjectiveTeamSuggestion.');
            }
            const localVarPath = `/events/{event_id}/suggestions/objectives`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SuggestionCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling createTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeam.');
            }
            const localVarPath = `/events/{event_id}/teams`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {number} category_id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryTeamSuggestion(event_id: number, category_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteCategoryTeamSuggestion.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id','Required parameter category_id was null or undefined when calling deleteCategoryTeamSuggestion.');
            }
            const localVarPath = `/events/{event_id}/suggestions/categories/{category_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {number} objective_id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectiveTeamSuggestion(event_id: number, objective_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteObjectiveTeamSuggestion.');
            }
            // verify required parameter 'objective_id' is not null or undefined
            if (objective_id === null || objective_id === undefined) {
                throw new RequiredError('objective_id','Required parameter objective_id was null or undefined when calling deleteObjectiveTeamSuggestion.');
            }
            const localVarPath = `/events/{event_id}/suggestions/objectives/{objective_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"objective_id"}}`, encodeURIComponent(String(objective_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'team_id' is not null or undefined
            if (team_id === null || team_id === undefined) {
                throw new RequiredError('team_id','Required parameter team_id was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/events/{event_id}/teams/{team_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(team_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeam.');
            }
            // verify required parameter 'team_id' is not null or undefined
            if (team_id === null || team_id === undefined) {
                throw new RequiredError('team_id','Required parameter team_id was null or undefined when calling getTeam.');
            }
            const localVarPath = `/events/{event_id}/teams/{team_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(team_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all suggestions for your team for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSuggestions(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeamSuggestions.');
            }
            const localVarPath = `/events/{event_id}/suggestions`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getTeams.');
            }
            const localVarPath = `/events/{event_id}/teams`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).addUsersToTeams(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).createCategoryTeamSuggestion(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjectiveTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).createObjectiveTeamSuggestion(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).createTeam(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {number} category_id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryTeamSuggestion(event_id: number, category_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).deleteCategoryTeamSuggestion(event_id, category_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {number} objective_id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectiveTeamSuggestion(event_id: number, objective_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).deleteObjectiveTeamSuggestion(event_id, objective_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).deleteTeam(event_id, team_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeam(event_id, team_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all suggestions for your team for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSuggestions(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Suggestions> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeamSuggestions(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamApiFetchParamCreator(configuration).getTeams(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
            return TeamApiFp(configuration).addUsersToTeams(event_id, body, options)(fetch, basePath);
        },
        /**
         * Creates a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any) {
            return TeamApiFp(configuration).createCategoryTeamSuggestion(event_id, body, options)(fetch, basePath);
        },
        /**
         * Creates a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {SuggestionCreate} body Suggestion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjectiveTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any) {
            return TeamApiFp(configuration).createObjectiveTeamSuggestion(event_id, body, options)(fetch, basePath);
        },
        /**
         * Creates a team for an event
         * @param {number} event_id Event Id
         * @param {TeamCreate} body Team to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(event_id: number, body: TeamCreate, options?: any) {
            return TeamApiFp(configuration).createTeam(event_id, body, options)(fetch, basePath);
        },
        /**
         * Deletes a suggestion for a category for your team for an event
         * @param {number} event_id Event Id
         * @param {number} category_id Category Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryTeamSuggestion(event_id: number, category_id: number, options?: any) {
            return TeamApiFp(configuration).deleteCategoryTeamSuggestion(event_id, category_id, options)(fetch, basePath);
        },
        /**
         * Deletes a suggestion for an objective for your team for an event
         * @param {number} event_id Event Id
         * @param {number} objective_id Objective Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectiveTeamSuggestion(event_id: number, objective_id: number, options?: any) {
            return TeamApiFp(configuration).deleteObjectiveTeamSuggestion(event_id, objective_id, options)(fetch, basePath);
        },
        /**
         * Deletes a team
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(event_id: number, team_id: number, options?: any) {
            return TeamApiFp(configuration).deleteTeam(event_id, team_id, options)(fetch, basePath);
        },
        /**
         * Fetches a team by id
         * @param {number} event_id Event Id
         * @param {number} team_id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(event_id: number, team_id: number, options?: any) {
            return TeamApiFp(configuration).getTeam(event_id, team_id, options)(fetch, basePath);
        },
        /**
         * Fetches all suggestions for your team for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamSuggestions(event_id: number, options?: any) {
            return TeamApiFp(configuration).getTeamSuggestions(event_id, options)(fetch, basePath);
        },
        /**
         * Fetches all teams for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(event_id: number, options?: any) {
            return TeamApiFp(configuration).getTeams(event_id, options)(fetch, basePath);
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Adds users to teams
     * @param {number} event_id Event Id
     * @param {Array<TeamUserCreate>} body Users to add to teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
        return TeamApiFp(this.configuration).addUsersToTeams(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a suggestion for a category for your team for an event
     * @param {number} event_id Event Id
     * @param {SuggestionCreate} body Suggestion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createCategoryTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any) {
        return TeamApiFp(this.configuration).createCategoryTeamSuggestion(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a suggestion for an objective for your team for an event
     * @param {number} event_id Event Id
     * @param {SuggestionCreate} body Suggestion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createObjectiveTeamSuggestion(event_id: number, body: SuggestionCreate, options?: any) {
        return TeamApiFp(this.configuration).createObjectiveTeamSuggestion(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a team for an event
     * @param {number} event_id Event Id
     * @param {TeamCreate} body Team to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createTeam(event_id: number, body: TeamCreate, options?: any) {
        return TeamApiFp(this.configuration).createTeam(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a suggestion for a category for your team for an event
     * @param {number} event_id Event Id
     * @param {number} category_id Category Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteCategoryTeamSuggestion(event_id: number, category_id: number, options?: any) {
        return TeamApiFp(this.configuration).deleteCategoryTeamSuggestion(event_id, category_id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a suggestion for an objective for your team for an event
     * @param {number} event_id Event Id
     * @param {number} objective_id Objective Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteObjectiveTeamSuggestion(event_id: number, objective_id: number, options?: any) {
        return TeamApiFp(this.configuration).deleteObjectiveTeamSuggestion(event_id, objective_id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a team
     * @param {number} event_id Event Id
     * @param {number} team_id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeam(event_id: number, team_id: number, options?: any) {
        return TeamApiFp(this.configuration).deleteTeam(event_id, team_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a team by id
     * @param {number} event_id Event Id
     * @param {number} team_id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeam(event_id: number, team_id: number, options?: any) {
        return TeamApiFp(this.configuration).getTeam(event_id, team_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all suggestions for your team for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamSuggestions(event_id: number, options?: any) {
        return TeamApiFp(this.configuration).getTeamSuggestions(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all teams for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeams(event_id: number, options?: any) {
        return TeamApiFp(this.configuration).getTeams(event_id, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling addUsersToTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addUsersToTeams.');
            }
            const localVarPath = `/events/{event_id}/teams/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TeamUserCreate&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the permissions of a user
         * @param {number} user_id User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(user_id: number, permissions: Array<Permission>, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling changePermissions.');
            }
            // verify required parameter 'permissions' is not null or undefined
            if (permissions === null || permissions === undefined) {
                throw new RequiredError('permissions','Required parameter permissions was null or undefined when calling changePermissions.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Permission&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(permissions || {}) : (permissions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a user by ID
         * @param {number} user_id User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling getUserById.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'event_id' is not null or undefined
            if (event_id === null || event_id === undefined) {
                throw new RequiredError('event_id','Required parameter event_id was null or undefined when calling getUsersForEvent.');
            }
            const localVarPath = `/events/{event_id}/users`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(event_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options: any = {}): FetchArgs {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling removeAuth.');
            }
            const localVarPath = `/users/remove-auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).addUsersToTeams(event_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes the permissions of a user
         * @param {number} user_id User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(user_id: number, permissions: Array<Permission>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).changePermissions(user_id, permissions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getAllUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a user by ID
         * @param {number} user_id User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserById(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<MinimalUser>; }> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsersForEvent(event_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).removeAuth(provider, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds users to teams
         * @param {number} event_id Event Id
         * @param {Array<TeamUserCreate>} body Users to add to teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
            return UserApiFp(configuration).addUsersToTeams(event_id, body, options)(fetch, basePath);
        },
        /**
         * Changes the permissions of a user
         * @param {number} user_id User Id
         * @param {Array<Permission>} permissions Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePermissions(user_id: number, permissions: Array<Permission>, options?: any) {
            return UserApiFp(configuration).changePermissions(user_id, permissions, options)(fetch, basePath);
        },
        /**
         * Fetches all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any) {
            return UserApiFp(configuration).getAllUsers(options)(fetch, basePath);
        },
        /**
         * Fetches the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UserApiFp(configuration).getUser(options)(fetch, basePath);
        },
        /**
         * Fetches a user by ID
         * @param {number} user_id User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(user_id: number, options?: any) {
            return UserApiFp(configuration).getUserById(user_id, options)(fetch, basePath);
        },
        /**
         * Fetches all users for an event
         * @param {number} event_id Event Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForEvent(event_id: number, options?: any) {
            return UserApiFp(configuration).getUsersForEvent(event_id, options)(fetch, basePath);
        },
        /**
         * Removes an authentication provider from the authenticated user
         * @param {string} provider Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAuth(provider: string, options?: any) {
            return UserApiFp(configuration).removeAuth(provider, options)(fetch, basePath);
        },
        /**
         * Updates the authenticated users display name
         * @param {UserUpdate} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: UserUpdate, options?: any) {
            return UserApiFp(configuration).updateUser(user, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Adds users to teams
     * @param {number} event_id Event Id
     * @param {Array<TeamUserCreate>} body Users to add to teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUsersToTeams(event_id: number, body: Array<TeamUserCreate>, options?: any) {
        return UserApiFp(this.configuration).addUsersToTeams(event_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Changes the permissions of a user
     * @param {number} user_id User Id
     * @param {Array<Permission>} permissions Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePermissions(user_id: number, permissions: Array<Permission>, options?: any) {
        return UserApiFp(this.configuration).changePermissions(user_id, permissions, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(options?: any) {
        return UserApiFp(this.configuration).getAllUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a user by ID
     * @param {number} user_id User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(user_id: number, options?: any) {
        return UserApiFp(this.configuration).getUserById(user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches all users for an event
     * @param {number} event_id Event Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersForEvent(event_id: number, options?: any) {
        return UserApiFp(this.configuration).getUsersForEvent(event_id, options)(this.fetch, this.basePath);
    }

    /**
     * Removes an authentication provider from the authenticated user
     * @param {string} provider Provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeAuth(provider: string, options?: any) {
        return UserApiFp(this.configuration).removeAuth(provider, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the authenticated users display name
     * @param {UserUpdate} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(user: UserUpdate, options?: any) {
        return UserApiFp(this.configuration).updateUser(user, options)(this.fetch, this.basePath);
    }

}

